# 动态连通性问题
- 说明：问题的输入是一列整数对，其中每个整数都表示一个某种类型的对象，一对整数p和q可以被理解为"p和q是相连的"。假设"相连"是一种等价关系，这也就意味着它具有：
    - 自反性：p和p是相连的
    - 对称性：如果p和q是相连的，那么q和p也是相连的。
    - 传递性：如果p和q是相连的且q和r是相连的，那么p和r也是相连的。
- 等价关系能够将对象分为多个等价类。在这里，当且仅当两个对象相连时它们才属于同一个等价类。
- 网络术语：
    - 将对象称为触点
    - 将整数对称为连接
    - 将等价类称为连通分量或者简称分量
    > 简单起见，建设我们有用0到N-1的整数所表示的N个触点。这样做并不会降低算法的通用性，因为可以将整数标识符和任意名称关联起来。
- quick-find算法的实现：定义了一个以触点为索引的数据结构int[] id，id[]元素表示的是连通分量。
- quick-union算法实现：也是定义了一个以触点为索引的数据结构int[] id,id[]元素表示的是另一个触点的名称，这样一个找一个直到找到根结点形成一个树装的结构
  - 由quick-union算法得出定义：一棵树的大小是它的节点的数量。树中的一个节点的"深度"是它到根节点的路径上的连接数。数的"高度"是它的所有节点中的最大深度。
  - quick-union有一个问题：如果输入的整数对是0-1，0-2，... ，0-N，有序的。那么树只有一个根节点。树的高度为N-1。那么处理N对整数对所需要的所有find()操作访问数组的总次数为N<sup>2</sup>.
- 加权quick-union算法：与其在union()中随意将一棵树连接到另一个棵树，我们会记录每一棵树的大小并总是将较小的树连接到较大的树上。
  - 加权quick-union需要新定义一个数组表示根节点所对应分量的大小，然后比较不同根节点分量的大小来将小分量树加到大分量树上。
  - 对于N个触点，加权quick-union算法构造的森林中的任意节点的深度最多为lgN。
  - 最坏的情况树的大小总是2<sup>n</sup>，对应的树的高度是n。当归并两个含有2<sup>n</sup>个节点的树是，我们得到的树含有2<sup>n+1</sup>个节点，由此将树的高度增加到了n+1。由此可以看到加权quick-union算法能够保证对数级别的性能。
- 路径压缩加权quick-union算法：使要查找的每个节点都连接到根节点。