# algorithm_exercise
algorithm_with_java
- 2022/03/29和30日更新：
    - 链表实现的stack栈: [LinkedList_Stack](./src/com/young/linked_list/LinkedListStack.java)
    - 链表实现queue队列: [LinkedList_Queue](./src/com/young/linked_list/LinkedListQueue.java)
    - 链表实现bag背包算法: [LinkedList_Bag](./src/com/young/linked_list/LinkedListBag.java)
- 2022/04/07日，算法分析实践测试代码
- union-find算法：
    - 2020/40/18日，测试Union-Find算法[union-find-exercise](./src/com/young/union_find_exercise/QuickUnionExercise.java)
    - 动态连通性知识点说明：[动态连通性知识点](./src/com/young/union_find_exercise/动态连通性知识点.md)
    - 算法实现：
        - 算法实现可视化图像：[union-find-visual](./src/com/young/union_find_exercise/union-find-detail.jpg)
        - quick-find算法[quick-find-algorithm](./src/com/young/union_find_exercise/QuickFindExercise.java)
        - quick-union算法[union-find-algorithm](./src/com/young/union_find_exercise/UnionFindExercise.java)
        - 加权quick-union算法[weighted-quick-union-algorithm](./src/com/young/union_find_exercise/WeightedQuickUnionExercise.java)
    
- 排序：[排序算法汇总](./src/com/young/sort_algorithm)
    - 排序知识点介绍：[排序知识点](./src/com/young/sort_algorithm/排序知识点.md)
    - 选择排序：[selection_sort](./src/com/young/sort_algorithm/Selection_Sort.java)
        - 首先，找到数组中最小的哪个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它不断地选择剩余元素之中的最小者。
        - 对于长度为N的数组，选择排序需要大于N<sup>2</sup>/2次比较和N次交换。
    - 插入排序：[Insertion_Sort](./src/com/young/sort_algorithm/Insertion_Sort.java)
        - 在计算机的实现中，为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位，这种算法叫做插入排序。
        - 插入排序所需的时间取决于输入中元素的初始顺序。
        - 对于随机排列的长度为N且主键不重复的数组，平均情况下插入排序需要～N<sup>2</sup>/4次比较以及～N<sup>2</sup>/4次交换。最坏情况下需要～N<sup>2</sup>/2次比较和～N<sup>2</sup>/2次交换，最好情况下需要N-1次比较和0次交换。
    - 希尔排序：[Shell_Sort](./src/com/young/sort_algorithm/Shell_Sort.java)
        - 希尔排序是对插入排序的进一步优化，将数组元素分成h个子数组，对子数组进行插入排序。然后将h递减为1，由于数组大部分已经排序了，所以h=1的插入排序就快很多了。
        - 图片示例[shell_sort_pic](./resources/imgs/IMG_8537.PNG)
    - 归并排序：
        - 将两个有序的数组归并成一个更大的有序数组，根据这个操作发明了一种简单的递归排序算法：归并排序。
        - 要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来。
        - 优点：任意长度的N的数组排序所需时间和NlogN成正比。
        - 缺点：所需的额外空间和N成正比。
        ***
        - 原地归并的抽象方法：
            - 实现归并的一种直接了当的办法是将两个不同的有序数组归并到第三个数组中，两个数组中的元素应该都实现了Comparable接口。
            - 实现方法很简单，创建一个适当大小的数组然后将两个输入数组中的元素一个个从小到大放入这个数组中。
        - 自顶向下的归并排序（递归使用）：[Merge_Up_Down_Sort](./src/com/young/sort_algorithm/Merge_Up_Down_Sort.java)
        - 自底向上的归并排序：[Merge_Down_Up_Sort](./src/com/young/sort_algorithm/Merge_Down_Up_Sort.java)
    - 快速排序:[Quick_Sort](./src/com/young/sort_algorithm/Quick_sort.java)
        - 快速排序递归地将子数组a\[lo..hi]排序，先用partition()方法将a\[j]放到一个合适的位置，然后在递归调用将其它位置的元素排序。
        - 切分方法：一般策略是先随意地取a\[lo]作为切分元素，即将会被排定的元素。然后从数组的左端开始向右扫描直到找到一个大于等于它的元素，再从右端开始向左端扫描直到找到一个小于等于它的元素。交换这两个元素的位置。如此继续，当两个指针相遇时，相遇的位置之前的元素小于等于a\[lo]，之后的元素大于等于a\[lo].将切分元素a\[lo]和左子数组最右侧的元素交换并返回这个位置即可。
- 优先队列：
    - 优先队列用例：[Priority_Queue_Case](./src/com/young/priority_queue/PQCase.java)
    - 堆的定义：当一棵二叉树的每个结点都大于等于它的两个子结点时，它被称为堆有序。
        - 根结点是堆有序的二叉树中的最大结点。
        - 二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级存储（不使用数组的第一个位置）。
        - 在一个堆中，位置k的结点的父结点的位置为 k/2 ，而它的两个子结点的位置则分别为 2k 和 2k+1 ，这样在不实用指针的情况下我们也可以通过计算数组的索引在树中上下移动；从a\[k]向上一层就令k等于k/2，向下一层则令k等于2k或2k+1。
        - 用数组（堆）实现的完全二叉树的结构严格，但足以让我们高效地实现优先队列。可实现对数级别的插入元素和删除最大元素的操作。
        - 一棵大小为N的完全二叉树的高度为 lgN 。
        - 堆的算法：
            - 由下至上的堆有序化（上浮 swim）
            - 由上至下的堆有序化（下沉 sink）
    - 堆有序可以用数组来表示。向数组中插入元素，则相当于从尾部插入，插入元素上浮到合适位置保持堆有序。删除第一个元素，并用尾部元素替换，则会下沉保持堆有序。
    - 堆有序对优先队列API的实现能够保证插入元素和删除元素这两个操作的用时和队列的大小仅成对数关系。
    - 基于堆的最大优先队列实现: [MaxPriorityQueue_Heap](./src/com/young/priority_queue/MaxPriorityQueueHeap.java)
    